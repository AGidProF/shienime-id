const express = require("express");
const axios = require("axios");
const fs = require("fs").promises;
const path = require("path");
const crypto = require("crypto");
const { HttpsProxyAgent } = require("https-proxy-agent");

const app = express();
const PORT = process.env.PORT || 3000;

// Simple p-limit alternative
function createLimit(concurrency) {
  let running = 0;
  const queue = [];
  
  return function limit(fn) {
    return new Promise((resolve, reject) => {
      queue.push({ fn, resolve, reject });
      tryNext();
    });
  };
  
  function tryNext() {
    if (running >= concurrency || queue.length === 0) return;
    
    running++;
    const { fn, resolve, reject } = queue.shift();
    
    Promise.resolve(fn())
      .then(resolve, reject)
      .finally(() => {
        running--;
        tryNext();
      });
  }
}

const proxySources = [
  "https://api.proxyscrape.com/v4/free-proxy-list/get?request=get_proxies&protocol=http&proxy_format=ipport&format=text&timeout=20000",
  "https://proxylist.geonode.com/api/proxy-list?protocols=http%2Chttps&limit=500&page=1&sort_by=lastChecked&sort_type=desc",
  "https://raw.githubusercontent.com/proxifly/free-proxy-list/refs/heads/main/proxies/protocols/http/data.txt",
  "https://raw.githubusercontent.com/ebrasha/abdal-proxy-hub/refs/heads/main/http-proxy-list-by-EbraSha.txt",
  "https://raw.githubusercontent.com/dpangestuw/Free-Proxy/refs/heads/main/http_proxies.txt",
  "https://raw.githubusercontent.com/elliottophellia/proxylist/refs/heads/master/results/mix_checked.txt",
  "https://raw.githubusercontent.com/monosans/proxy-list/refs/heads/main/proxies/http.txt",
  "https://raw.githubusercontent.com/databay-labs/free-proxy-list/refs/heads/master/http.txt",
  "https://raw.githubusercontent.com/MrMarble/proxy-list/refs/heads/main/all.txt",
  "https://raw.githubusercontent.com/saisuiu/Lionkings-Http-Proxys-Proxies/refs/heads/main/free.txt",
  "https://raw.githubusercontent.com/vmheaven/VMHeaven-Free-Proxy-Updated/refs/heads/main/http.txt",
  "https://raw.githubusercontent.com/vmheaven/VMHeaven-Free-Proxy-Updated/refs/heads/main/https.txt",
  "https://raw.githubusercontent.com/iplocate/free-proxy-list/refs/heads/main/protocols/http.txt"
];

// ===============================
// FILE-BASED SMART CACHE SYSTEM WITH AUTO-RESET
// ===============================
class FileBasedSmartCache {
  constructor() {
    this.cacheFile = path.join(__dirname, 'cache.txt');
    this.maxCacheSize = 200 * 1024 * 1024; // 200MB
    this.resetInterval = 3 * 60 * 60 * 1000; // 3 hours
    this.maxFileSize = 50 * 1024 * 1024; // 50MB max file size for caching
    
    // In-memory stats (reset every 3 hours)
    this.stats = {
      hitCount: 0,
      missCount: 0,
      skipCount: 0,
      evictedCount: 0,
      resetCount: 0,
      lastReset: new Date(),
      currentCacheSize: 0,
      totalEntries: 0
    };
    
    // Video/streaming file extensions that shouldn't be cached
    this.streamingExtensions = new Set([
      '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
      '.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a',
      '.zip', '.rar', '.7z', '.tar', '.gz',
      '.iso', '.bin', '.dmg'
    ]);
    
    // Initialize cache file and start reset timer
    this.initializeCache();
    this.startResetTimer();
  }

  async initializeCache() {
    try {
      // Create cache file if it doesn't exist
      try {
        await fs.access(this.cacheFile);
        await this.updateCacheStats();
        console.log('üíæ Cache file found, stats updated');
      } catch (error) {
        await fs.writeFile(this.cacheFile, '{}');
        console.log('üíæ Cache file created');
      }
    } catch (error) {
      console.error('‚ùå Error initializing cache:', error.message);
    }
  }

  async updateCacheStats() {
    try {
      const stats = await fs.stat(this.cacheFile);
      this.stats.currentCacheSize = stats.size;
      
      const content = await fs.readFile(this.cacheFile, 'utf8');
      const cache = JSON.parse(content);
      this.stats.totalEntries = Object.keys(cache).length;
    } catch (error) {
      console.error('‚ùå Error updating cache stats:', error.message);
    }
  }

  generateKey(url) {
    return crypto.createHash('md5').update(url).digest('hex');
  }

  shouldCache(url, contentType, contentLength, headers) {
    // Don't cache if content is too large
    if (contentLength && contentLength > this.maxFileSize) {
      return false;
    }

    // Don't cache video/audio streams
    if (contentType) {
      const type = contentType.toLowerCase();
      if (type.includes('video/') || 
          type.includes('audio/') || 
          type.includes('application/octet-stream') ||
          type.includes('application/zip') ||
          type.includes('application/x-rar')) {
        return false;
      }
    }

    // Check file extension in URL
    const urlPath = new URL(url).pathname.toLowerCase();
    for (const ext of this.streamingExtensions) {
      if (urlPath.includes(ext)) {
        return false;
      }
    }

    // Don't cache if response has Accept-Ranges header (indicates streaming support)
    if (headers && headers['accept-ranges']) {
      return false;
    }

    return true;
  }

  async set(url, data, headers, contentType) {
    try {
      const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data.toString());
      const contentLength = dataBuffer.length;
      
      if (!this.shouldCache(url, contentType, contentLength, headers)) {
        this.stats.skipCount++;
        console.log(`üö´ Skipping cache for streaming/large content: ${url} (${Math.round(contentLength/1024)}KB)`);
        return false;
      }

      // Check if adding this would exceed cache size limit
      if (this.stats.currentCacheSize + contentLength > this.maxCacheSize) {
        console.log(`‚ö†Ô∏è Cache size limit would be exceeded, triggering cleanup`);
        await this.cleanupOldEntries();
        
        // If still too large after cleanup, skip caching
        if (this.stats.currentCacheSize + contentLength > this.maxCacheSize) {
          this.stats.skipCount++;
          console.log(`üö´ Skipping cache due to size limit: ${url} (${Math.round(contentLength/1024)}KB)`);
          return false;
        }
      }

      const key = this.generateKey(url);
      const now = Date.now();
      
      // Read existing cache
      let cache = {};
      try {
        const content = await fs.readFile(this.cacheFile, 'utf8');
        cache = JSON.parse(content);
      } catch (error) {
        cache = {};
      }

      // Store cache entry
      cache[key] = {
        url: url,
        data: dataBuffer.toString('base64'),
        headers: headers || {},
        contentType: contentType || 'application/octet-stream',
        timestamp: now,
        hits: 0,
        size: contentLength
      };

      // Write to file
      await fs.writeFile(this.cacheFile, JSON.stringify(cache));
      
      // Update stats
      this.stats.currentCacheSize += contentLength;
      this.stats.totalEntries = Object.keys(cache).length;
      
      console.log(`üíæ Cache stored: ${url} (${Math.round(contentLength/1024)}KB, ${this.stats.totalEntries} entries, ${Math.round(this.stats.currentCacheSize/1024/1024)}MB)`);
      return true;

    } catch (error) {
      console.error('‚ùå Error setting cache:', error.message);
      return false;
    }
  }

  async get(url) {
    try {
      const key = this.generateKey(url);
      
      const content = await fs.readFile(this.cacheFile, 'utf8');
      const cache = JSON.parse(content);
      
      const item = cache[key];
      if (!item) {
        this.stats.missCount++;
        return null;
      }
      
      // Update hit count and write back
      item.hits++;
      cache[key] = item;
      
      // Write updated cache (fire and forget to avoid blocking)
      fs.writeFile(this.cacheFile, JSON.stringify(cache)).catch(err => {
        console.error('‚ùå Error updating hit count:', err.message);
      });
      
      this.stats.hitCount++;
      
      return {
        data: Buffer.from(item.data, 'base64'),
        headers: item.headers,
        contentType: item.contentType,
        hits: item.hits
      };

    } catch (error) {
      console.error('‚ùå Error getting from cache:', error.message);
      this.stats.missCount++;
      return null;
    }
  }

  async invalidate(url) {
    try {
      const key = this.generateKey(url);
      
      const content = await fs.readFile(this.cacheFile, 'utf8');
      const cache = JSON.parse(content);
      
      if (cache[key]) {
        this.stats.currentCacheSize -= (cache[key].size || 0);
        delete cache[key];
        
        await fs.writeFile(this.cacheFile, JSON.stringify(cache));
        this.stats.totalEntries = Object.keys(cache).length;
        
        console.log(`üóëÔ∏è Cache invalidated: ${url}`);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error('‚ùå Error invalidating cache:', error.message);
      return false;
    }
  }

  async clear() {
    try {
      await fs.writeFile(this.cacheFile, '{}');
      const oldSize = this.stats.currentCacheSize;
      const oldEntries = this.stats.totalEntries;
      
      this.stats.currentCacheSize = 0;
      this.stats.totalEntries = 0;
      
      console.log(`üóëÔ∏è Cache cleared: ${oldEntries} entries (${Math.round(oldSize/1024/1024)}MB) removed`);
      return true;
    } catch (error) {
      console.error('‚ùå Error clearing cache:', error.message);
      return false;
    }
  }

  async cleanupOldEntries() {
    try {
      const content = await fs.readFile(this.cacheFile, 'utf8');
      const cache = JSON.parse(content);
      
      // Sort entries by timestamp (oldest first) and hits (least used first)
      const entries = Object.entries(cache).sort((a, b) => {
        const scoreA = a[1].timestamp + (a[1].hits * 1000 * 60 * 60); // Boost score by hits
        const scoreB = b[1].timestamp + (b[1].hits * 1000 * 60 * 60);
        return scoreA - scoreB;
      });
      
      // Remove oldest 20% of entries
      const removeCount = Math.ceil(entries.length * 0.2);
      const newCache = {};
      let removedSize = 0;
      
      for (let i = removeCount; i < entries.length; i++) {
        const [key, value] = entries[i];
        newCache[key] = value;
      }
      
      for (let i = 0; i < removeCount; i++) {
        removedSize += entries[i][1].size || 0;
      }
      
      await fs.writeFile(this.cacheFile, JSON.stringify(newCache));
      
      this.stats.currentCacheSize -= removedSize;
      this.stats.totalEntries = Object.keys(newCache).length;
      this.stats.evictedCount += removeCount;
      
      console.log(`üßπ Cache cleanup: ${removeCount} entries removed (${Math.round(removedSize/1024/1024)}MB freed)`);
      
    } catch (error) {
      console.error('‚ùå Error during cleanup:', error.message);
    }
  }

  startResetTimer() {
    // Reset cache every 3 hours
    setInterval(async () => {
      await this.resetCache();
    }, this.resetInterval);

    console.log(`‚è∞ Cache reset timer started (every 3 hours)`);
  }

  async resetCache() {
    try {
      const oldSize = this.stats.currentCacheSize;
      const oldEntries = this.stats.totalEntries;
      const oldHits = this.stats.hitCount;
      const oldMisses = this.stats.missCount;
      const oldSkips = this.stats.skipCount;
      
      // Clear cache file
      await fs.writeFile(this.cacheFile, '{}');
      
      // Reset stats
      this.stats = {
        hitCount: 0,
        missCount: 0,
        skipCount: 0,
        evictedCount: 0,
        resetCount: this.stats.resetCount + 1,
        lastReset: new Date(),
        currentCacheSize: 0,
        totalEntries: 0
      };
      
      console.log(`üîÑ SCHEDULED CACHE RESET #${this.stats.resetCount}`);
      console.log(`   üìä Previous session stats:`);
      console.log(`   üíæ Size: ${Math.round(oldSize/1024/1024)}MB (${oldEntries} entries)`);
      console.log(`   üéØ Hits: ${oldHits}, Misses: ${oldMisses}, Skips: ${oldSkips}`);
      console.log(`   üìà Hit Rate: ${oldHits + oldMisses > 0 ? Math.round(oldHits/(oldHits + oldMisses)*100) : 0}%`);
      console.log(`   üöÄ Memory freed, logs reset, ready for next 3-hour cycle`);
      
    } catch (error) {
      console.error('‚ùå Error during scheduled cache reset:', error.message);
    }
  }

  getStats() {
    const totalRequests = this.stats.hitCount + this.stats.missCount + this.stats.skipCount;
    const hitRate = totalRequests > 0 ? ((this.stats.hitCount / totalRequests) * 100).toFixed(2) + '%' : '0%';
    const skipRate = totalRequests > 0 ? ((this.stats.skipCount / totalRequests) * 100).toFixed(2) + '%' : '0%';
    
    const nextReset = new Date(this.stats.lastReset.getTime() + this.resetInterval);
    const timeToReset = Math.max(0, nextReset.getTime() - Date.now());
    
    return {
      // Current session stats
      totalEntries: this.stats.totalEntries,
      currentCacheSize: this.stats.currentCacheSize,
      maxCacheSize: this.maxCacheSize,
      hitCount: this.stats.hitCount,
      missCount: this.stats.missCount,
      skipCount: this.stats.skipCount,
      evictedCount: this.stats.evictedCount,
      hitRate: hitRate,
      skipRate: skipRate,
      
      // Reset info
      resetCount: this.stats.resetCount,
      lastReset: this.stats.lastReset,
      nextReset: nextReset,
      timeToNextReset: Math.round(timeToReset / 1000 / 60) + ' minutes',
      resetInterval: '3 hours',
      
      // Size info
      maxFileSize: this.maxFileSize,
      sizeMB: Math.round(this.stats.currentCacheSize / 1024 / 1024 * 100) / 100,
      maxSizeMB: Math.round(this.maxCacheSize / 1024 / 1024),
      sizeUsagePercent: Math.round((this.stats.currentCacheSize / this.maxCacheSize) * 100),
      avgFileSize: this.stats.totalEntries > 0 ? Math.round(this.stats.currentCacheSize / this.stats.totalEntries) : 0,
      
      // Cache strategy
      cacheStrategy: 'File-based with 3-hour auto-reset',
      streamingSupport: 'Videos bypass cache automatically'
    };
  }

  destroy() {
    // Cleanup method for graceful shutdown
    console.log('üîÑ Cache manager shutting down...');
  }
}

// ===============================
// COMPREHENSIVE PROXY MANAGER (unchanged from original)
// ===============================
class ProxyManager {
  constructor() {
    this.workingProxies = new Map();
    this.allProxies = new Set();
    this.deadProxies = new Map();
    this.testingQueue = new Set();
    this.fastProxies = new Set();
    
    this.isFetching = false;
    this.isTesting = false;
    this.testingProgress = { current: 0, total: 0, batch: 0 };
    
    this.stats = {
      totalFetched: 0,
      totalTested: 0,
      totalWorking: 0,
      totalDead: 0,
      testingSessions: 0,
      lastUpdate: null,
      lastFullScan: null,
      avgTestTime: 0,
      totalTestTime: 0,
      racingWins: 0,
      instantSwitches: 0
    };
    
    this.intervals = {};
  }

  async fetchProxies() {
    if (this.isFetching) {
      console.log("‚è≥ Fetch already in progress, skipping...");
      return this.allProxies;
    }

    this.isFetching = true;
    console.log("üîÑ Fetching proxies from all sources...");
    let newProxies = [];
    
    const fetchPromises = proxySources.map(async (url, index) => {
      try {
        console.log(`üì° [${index + 1}/${proxySources.length}] Fetching from: ${url.split('/')[2]}`);
        const res = await axios.get(url, { 
          timeout: 20000,
          maxRedirects: 3
        });
        
        let proxies = [];
        if (url.includes("geonode")) {
          if (res.data && res.data.data) {
            proxies = res.data.data.map(p => `${p.ip}:${p.port}`);
          }
        } else {
          proxies = res.data
            .split("\n")
            .map(l => l.trim().replace(/^http(s)?:\/\//, ""))
            .filter(l => l && l.includes(':') && l.split(':').length === 2)
            .filter(l => {
              const [ip, port] = l.split(':');
              return ip.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) && 
                     port.match(/^\d+$/) && 
                     parseInt(port) > 0 && 
                     parseInt(port) < 65536;
            });
        }
        
        newProxies.push(...proxies);
        console.log(`‚úÖ [${index + 1}/${proxySources.length}] Got ${proxies.length} proxies from: ${url.split('/')[2]}`);
        return proxies.length;
      } catch (err) {
        console.log(`‚ùå [${index + 1}/${proxySources.length}] Failed: ${url.split('/')[2]} - ${err.message}`);
        return 0;
      }
    });
    
    const results = await Promise.allSettled(fetchPromises);
    const totalFetched = results.reduce((sum, result) => {
      return sum + (result.status === 'fulfilled' ? result.value : 0);
    }, 0);
    
    const uniqueProxies = [...new Set(newProxies)];
    const beforeSize = this.allProxies.size;
    uniqueProxies.forEach(p => this.allProxies.add(p));
    const newCount = this.allProxies.size - beforeSize;
    
    this.stats.totalFetched = this.allProxies.size;
    this.stats.lastUpdate = new Date();
    
    console.log(`üìä Fetch complete: ${uniqueProxies.length} total, ${newCount} new, ${this.allProxies.size} unique proxies`);
    
    this.isFetching = false;
    return this.allProxies;
  }

  async testProxy(proxy, testUrls = ["https://otakudesu.best/anime/watanare-sub-indo", "https://v1.samehadaku.how"]) {
    const startTime = Date.now();
    
    for (const testUrl of testUrls) {
      try {
        const agent = new HttpsProxyAgent(`http://${proxy}`);
        const res = await axios.get(testUrl, {
          httpAgent: agent,
          httpsAgent: agent,
          timeout: 10000,
          maxRedirects: 3,
          validateStatus: () => true
        });
        
        const responseTime = Date.now() - startTime;
        
        if (res.status === 200 && res.data) {
          return { 
            proxy, 
            responseTime, 
            success: true, 
            testUrl,
            dataSize: Buffer.isBuffer(res.data) ? res.data.length : res.data.toString().length
          };
        }
      } catch (err) {
        continue;
      }
    }
    
    return { 
      proxy, 
      responseTime: Date.now() - startTime, 
      success: false 
    };
  }

  getBestWorkingProxy() {
    if (this.workingProxies.size === 0) return null;
    
    const sortedProxies = Array.from(this.workingProxies.entries())
      .map(([proxy, metadata]) => ({
        proxy,
        metadata,
        score: this.calculateProxyScore(metadata)
      }))
      .sort((a, b) => b.score - a.score);
    
    const topCount = Math.max(1, Math.ceil(sortedProxies.length * 0.1));
    const randomIndex = Math.floor(Math.random() * topCount);
    return sortedProxies[randomIndex].proxy;
  }

  calculateProxyScore(metadata) {
    const successRate = metadata.successCount / (metadata.successCount + metadata.failCount);
    const responseScore = 1000 / (metadata.avgResponseTime + 100);
    const ageBonus = Math.min(1, (Date.now() - metadata.addedAt.getTime()) / (24 * 60 * 60 * 1000));
    
    return successRate * responseScore * (1 + ageBonus);
  }

  removeFailedProxy(proxy) {
    if (this.workingProxies.has(proxy)) {
      const metadata = this.workingProxies.get(proxy);
      this.workingProxies.delete(proxy);
      this.fastProxies.delete(proxy);
      this.deadProxies.set(proxy, {
        lastTested: new Date(),
        failCount: metadata.failCount + 1,
        lastError: 'Request failed'
      });
      this.stats.totalWorking = this.workingProxies.size;
      this.stats.totalDead = this.deadProxies.size;
      console.log(`üóëÔ∏è Removed failed proxy: ${proxy}`);
    }
  }

  startBackgroundTasks() {
    console.log("üöÄ Starting comprehensive proxy manager...");
    
    this.fetchProxies().then(() => {
      setTimeout(() => this.testAllProxies(), 5000);
    });

    this.intervals.fetch = setInterval(async () => {
      await this.fetchProxies();
      if (!this.isTesting) {
        setTimeout(() => this.testAllProxies(), 10000);
      }
    }, 30 * 60 * 1000);
  }

  async testAllProxies() {
    if (this.isTesting) return;
    this.isTesting = true;
    
    const untestedProxies = Array.from(this.allProxies).filter(proxy => 
      !this.workingProxies.has(proxy) && 
      !this.deadProxies.has(proxy) &&
      !this.testingQueue.has(proxy)
    );
    
    if (untestedProxies.length === 0) {
      this.isTesting = false;
      return;
    }

    console.log(`üöÄ Testing ${untestedProxies.length} proxies...`);
    
    const batchSize = 100;
    const concurrency = 25;
    const limit = createLimit(concurrency);
    
    for (let i = 0; i < untestedProxies.length; i += batchSize) {
      const batch = untestedProxies.slice(i, i + batchSize);
      
      batch.forEach(proxy => this.testingQueue.add(proxy));
      
      const tasks = batch.map(proxy =>
        limit(async () => {
          const result = await this.testProxy(proxy);
          this.testingQueue.delete(proxy);
          
          const now = new Date();
          
          if (result.success) {
            this.workingProxies.set(proxy, {
              successCount: 1,
              failCount: 0,
              totalResponseTime: result.responseTime,
              avgResponseTime: result.responseTime,
              lastTested: now,
              addedAt: now,
              successRate: 1.0
            });
          } else {
            this.deadProxies.set(proxy, {
              lastTested: now,
              failCount: 1,
              lastError: 'Connection failed'
            });
          }
          
          return result;
        })
      );

      await Promise.allSettled(tasks);
    }

    this.stats.totalWorking = this.workingProxies.size;
    this.stats.totalDead = this.deadProxies.size;
    
    console.log(`‚úÖ Testing complete: ${this.workingProxies.size} working, ${this.deadProxies.size} dead`);
    this.isTesting = false;
  }

  getStats() {
    return {
      ...this.stats,
      workingProxiesCount: this.workingProxies.size,
      deadProxiesCount: this.deadProxies.size,
      totalProxiesCount: this.allProxies.size,
      isTesting: this.isTesting,
      isFetching: this.isFetching
    };
  }
}

// ===============================
// ENHANCED FETCH WITH VIDEO STREAMING SUPPORT (using file cache)
// ===============================
async function fetchWithProxy(url, req, maxRetries = 8, useCache = true, cache) {
  // Check if this is a range request (video streaming)
  const isRangeRequest = req.headers.range;
  
  // For range requests, don't use cache
  if (isRangeRequest) {
    console.log(`üìπ Range request detected for: ${url} (${req.headers.range})`);
    useCache = false;
  }

  // Check cache first (only for non-range requests)
  if (useCache) {
    const cached = await cache.get(url);
    if (cached) {
      console.log(`‚ö° Cache hit: ${url}`);
      return {
        data: cached.data,
        headers: cached.headers,
        contentType: cached.contentType,
        fromCache: true,
        cacheHits: cached.hits
      };
    }
  }

  if (proxyManager.workingProxies.size === 0) {
    throw new Error(`No working proxies available`);
  }

  const startTime = Date.now();
  let usedProxies = new Set();

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const proxy = proxyManager.getBestWorkingProxy();
    
    if (!proxy || usedProxies.has(proxy)) {
      if (usedProxies.size >= proxyManager.workingProxies.size) {
        usedProxies.clear();
      }
      if (!proxy) {
        throw new Error("No working proxies available");
      }
    }

    usedProxies.add(proxy);
    
    try {
      const agent = new HttpsProxyAgent(`http://${proxy}`);
      
      // Prepare headers for proxy request
      const proxyHeaders = {};
      
      // Forward important headers for video streaming
      if (req.headers.range) {
        proxyHeaders.Range = req.headers.range;
      }
      if (req.headers['user-agent']) {
        proxyHeaders['User-Agent'] = req.headers['user-agent'];
      }
      if (req.headers.referer) {
        proxyHeaders.Referer = req.headers.referer;
      }
      
      const response = await axios.get(url, {
        httpAgent: agent,
        httpsAgent: agent,
        timeout: isRangeRequest ? 15000 : 8000, // Longer timeout for video
        maxRedirects: 3,
        validateStatus: () => true,
        responseType: 'arraybuffer',
        headers: proxyHeaders
      });
      
      const duration = Date.now() - startTime;
      
      // Accept both 200 (full content) and 206 (partial content for range requests)
      if (response.status === 200 || response.status === 206) {
        const contentType = response.headers['content-type'];
        const contentLength = response.headers['content-length'];
        
        console.log(`‚úÖ Success with proxy: ${proxy} (${duration}ms, ${response.status}, ${Math.round(response.data.length/1024)}KB)`);
        
        // Only cache if it's cacheable content
        let cached = false;
        if (useCache && response.status === 200) { // Don't cache partial content
          cached = await cache.set(url, response.data, response.headers, contentType);
        }
        
        return {
          data: response.data,
          headers: response.headers,
          contentType: contentType,
          proxy: proxy,
          duration: duration,
          attempts: attempt,
          fromCache: false,
          status: response.status,
          cached: cached
        };
      } else {
        console.log(`‚ö†Ô∏è Non-success response from ${proxy}: ${response.status}`);
        continue;
      }
      
    } catch (err) {
      console.log(`‚ùå Failed with proxy: ${proxy} (attempt ${attempt}/${maxRetries}) - ${err.message}`);
      proxyManager.removeFailedProxy(proxy);
      
      if (attempt === maxRetries) {
        const duration = Date.now() - startTime;
        throw new Error(`All ${maxRetries} attempts failed after ${duration}ms`);
      }
    }
  }
}

// Initialize managers
const proxyManager = new ProxyManager();
const cache = new FileBasedSmartCache(); // Use new file-based cache

// ===============================
// EXPRESS ROUTES WITH VIDEO STREAMING SUPPORT
// ===============================
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Range');
  next();
});

// Enhanced main proxy endpoint with video streaming support
app.get('/proxies', async (req, res) => {
  const { url, nocache } = req.query;
  
  if (!url) {
    return res.status(400).json({ 
      error: 'URL parameter is required',
      example: '/proxies?url=https://example.com',
      videoStreaming: 'Automatically supports video streaming with range requests'
    });
  }

  try {
    new URL(url);
  } catch (err) {
    return res.status(400).json({ error: 'Invalid URL format' });
  }

  const startTime = Date.now();
  const useCache = nocache !== '1' && nocache !== 'true';
  const isRangeRequest = !!req.headers.range;

  try {
    console.log(`üåê Fetching: ${url} ${isRangeRequest ? '(RANGE REQUEST)' : ''} ${!useCache ? '(NO-CACHE)' : ''}`);
    
    const result = await fetchWithProxy(url, req, 8, useCache, cache);
    
    // Set appropriate headers for response
    if (result.contentType) {
      res.set('Content-Type', result.contentType);
    }
    
    // Handle video streaming headers
    if (result.status === 206) {
      res.status(206);
      if (result.headers['content-range']) {
        res.set('Content-Range', result.headers['content-range']);
      }
      if (result.headers['accept-ranges']) {
        res.set('Accept-Ranges', result.headers['accept-ranges']);
      }
    }
    
    // Set content length
    if (result.headers['content-length']) {
      res.set('Content-Length', result.headers['content-length']);
    }
    
    // Enable range requests for video content
    if (result.contentType && (result.contentType.includes('video/') || result.contentType.includes('audio/'))) {
      res.set('Accept-Ranges', 'bytes');
    }
    
    // Performance headers
    res.set('X-Proxy-Used', result.proxy || 'cache');
    res.set('X-Response-Time', `${result.duration || Date.now() - startTime}ms`);
    res.set('X-Attempts', result.attempts || 0);
    res.set('X-Cache-Status', result.fromCache ? 'HIT' : (result.cached ? 'STORED' : 'SKIP'));
    res.set('X-Available-Proxies', proxyManager.workingProxies.size);
    res.set('X-Content-Size', Math.round(result.data.length / 1024) + 'KB');
    res.set('X-Range-Request', isRangeRequest ? 'YES' : 'NO');
    
    res.send(result.data);
    
  } catch (err) {
    await cache.invalidate(url);
    
    const duration = Date.now() - startTime;
    console.error(`‚ùå Error after ${duration}ms:`, err.message);
    
    res.status(500).json({ 
      error: 'Failed to fetch URL through proxy',
      details: err.message,
      duration: `${duration}ms`,
      availableProxies: proxyManager.workingProxies.size,
      isRangeRequest: isRangeRequest,
      suggestion: 'For video streaming, ensure your player supports range requests properly'
    });
  }
});

// Get proxy statistics with cache info
app.get('/proxies/stats', async (req, res) => {
  await cache.updateCacheStats(); // Update stats before showing
  res.json({
    stats: proxyManager.getStats(),
    cache: cache.getStats()
  });
});

// Cache management
app.get('/proxies/cache', async (req, res) => {
  const showEntries = req.query.entries === '1';
  
  await cache.updateCacheStats();
  
  const response = {
    stats: cache.getStats(),
    fileBasedCache: {
      cacheFile: 'cache.txt',
      maxSize: '200MB',
      resetInterval: '3 hours',
      autoCleanup: 'Yes - removes oldest 20% when size limit reached'
    },
    streamingSupport: {
      maxFileSize: Math.round(cache.maxFileSize / 1024 / 1024) + 'MB',
      skipExtensions: Array.from(cache.streamingExtensions),
      videoHandling: 'Videos bypass cache and support range requests'
    }
  };
  
  if (showEntries) {
    try {
      const fs = require('fs').promises;
      const content = await fs.readFile(cache.cacheFile, 'utf8');
      const cacheData = JSON.parse(content);
      
      response.entries = Object.values(cacheData)
        .map(entry => ({
          url: entry.url,
          contentType: entry.contentType || 'unknown',
          size: Math.round(entry.size / 1024) + 'KB',
          hits: entry.hits,
          age: Math.round((Date.now() - entry.timestamp) / 1000) + 's'
        }))
        .sort((a, b) => b.hits - a.hits)
        .slice(0, 50); // Show only top 50 entries
        
    } catch (error) {
      response.entries = [];
      response.error = 'Could not read cache entries';
    }
  }
  
  res.json(response);
});

app.delete('/proxies/cache', async (req, res) => {
  const { url } = req.query;
  
  if (url) {
    const deleted = await cache.invalidate(url);
    res.json({ 
      message: deleted ? `Cache deleted for: ${url}` : `Cache entry not found: ${url}`,
      deleted
    });
  } else {
    const cleared = await cache.clear();
    res.json({ 
      message: cleared ? 'All cache cleared' : 'Failed to clear cache',
      cleared
    });
  }
});

// Force cache reset endpoint
app.post('/proxies/cache/reset', async (req, res) => {
  await cache.resetCache();
  res.json({ 
    message: 'Cache manually reset',
    nextAutoReset: new Date(Date.now() + cache.resetInterval),
    resetCount: cache.stats.resetCount
  });
});
// Tambahkan di server Anda
app.get('/dashboard', (req, res) => {
  res.sendFile(path.join(__dirname, 'dashboard.html'));
});
// Health check
app.get('/health', async (req, res) => {
  const stats = proxyManager.getStats();
  await cache.updateCacheStats();
  const cacheStats = cache.getStats();
  
  res.json({
    status: 'ok',
    uptime: Math.round(process.uptime()),
    memory: {
      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
    },
    proxies: {
      total: stats.totalProxiesCount,
      working: stats.workingProxiesCount,
      dead: stats.deadProxiesCount
    },
    cache: {
      type: 'file-based',
      file: 'cache.txt',
      size: cacheStats.totalEntries,
      sizeMB: cacheStats.sizeMB,
      hitRate: cacheStats.hitRate,
      skipRate: cacheStats.skipRate,
      resetCount: cacheStats.resetCount,
      timeToNextReset: cacheStats.timeToNextReset
    },
    videoStreaming: {
      rangeRequestSupport: 'enabled',
      cacheBypass: 'automatic for videos',
      maxCacheFileSize: Math.round(cache.maxFileSize / 1024 / 1024) + 'MB'
    }
  });
});

// API documentation
app.get('/', async (req, res) => {
  await cache.updateCacheStats();
  
  res.json({
    name: 'Enhanced Proxy Bridge API with File-Based Cache & Auto-Reset',
    version: '5.0.0',
    description: 'High-performance proxy bridge with file-based smart caching, auto-reset, and full video streaming support',
    
    endpoints: {
      'Main Proxy': {
        'GET /proxies?url=<URL>': 'Proxy any URL with automatic video streaming support',
        'GET /proxies?url=<URL>&nocache=1': 'Bypass cache (automatically done for videos)'
      },
      'Statistics': {
        'GET /proxies/stats': 'Get proxy and cache statistics',
        'GET /health': 'System health check'
      },
      'Cache Management': {
        'GET /proxies/cache': 'View cache statistics and streaming info',
        'GET /proxies/cache?entries=1': 'View cached entries (top 50)',
        'DELETE /proxies/cache': 'Clear all cache',
        'DELETE /proxies/cache?url=<URL>': 'Delete specific cache entry',
        'POST /proxies/cache/reset': 'Force manual cache reset'
      },
      'Documentation': {
        'GET /': 'This documentation'
      }
    },

    newFeatures: [
      'üìÅ File-based cache system (cache.txt)',
      'üîÑ Auto-reset every 3 hours to prevent server overload',
      'üìä Reset log tracking and statistics',
      'üíæ 200MB cache size limit with smart cleanup',
      'üßπ Automatic oldest-entry removal when limit reached',
      '‚è∞ Scheduled cache resets with detailed logging',
      'üöÄ Memory-efficient file-based storage',
      'üìà Enhanced cache statistics and monitoring'
    ],

    videoStreamingFeatures: [
      'üé¨ Automatic range request support for video streaming',
      'üì± Mobile-friendly video playback',
      '‚ö° Smart cache bypass for large files and videos',
      'üéØ Proper HTTP 206 Partial Content responses',
      'üì∫ Support for all video formats (MP4, WebM, MKV, etc.)',
      'üîÑ Seamless seeking and buffering',
      'üíæ Intelligent caching for small files only',
      'üö´ Automatic detection of streaming content'
    ],

    cacheSystem: {
      type: 'File-based with auto-reset',
      file: 'cache.txt',
      maxSize: '200MB',
      resetInterval: '3 hours',
      currentStats: cache.getStats(),
      benefits: [
        'Prevents memory bloat on server',
        'Survives server restarts',
        'Automatic cleanup and reset',
        'Detailed logging of cache operations',
        'Smart size management'
      ]
    },

    examples: {
      webpage: '/proxies?url=https://example.com',
      video: '/proxies?url=https://example.com/video.mp4',
      image: '/proxies?url=https://example.com/image.jpg',
      api: '/proxies?url=https://api.example.com/data.json'
    },

    cacheIntelligence: {
      smartDetection: 'Automatically detects video/audio/large files',
      bypassCriteria: [
        'Content-Type contains video/ or audio/',
        'File extension matches streaming formats',
        'File size exceeds ' + Math.round(cache.maxFileSize / 1024 / 1024) + 'MB',
        'Response has Accept-Ranges header',
        'Range requests (HTTP 206 responses)'
      ],
      cachedContent: 'HTML, CSS, JS, small images, JSON, XML',
      streamingFormats: Array.from(cache.streamingExtensions)
    },

    performanceOptimizations: [
      'File-based cache storage for memory efficiency',
      '3-hour auto-reset prevents cache bloat',
      'Smart cleanup removes oldest/least-used entries',
      'Range request forwarding for video streaming',
      'Proper HTTP status code handling (200/206)',
      'Content-Length and Content-Range header preservation',
      'Accept-Ranges header for video content',
      'Memory-efficient large file handling'
    ],

    troubleshooting: {
      videoLag: 'Videos now properly support range requests - no more lag!',
      largeFiles: 'Files over ' + Math.round(cache.maxFileSize / 1024 / 1024) + 'MB automatically bypass cache',
      mobilePlayers: 'Full support for mobile video players and seeking',
      streamingServices: 'Compatible with video streaming platforms',
      cacheResets: 'Cache auto-resets every 3 hours to maintain performance',
      serverLoad: 'File-based cache prevents memory issues'
    },

    currentStats: {
      proxies: proxyManager.getStats(),
      cache: cache.getStats(),
      uptime: Math.round(process.uptime()) + 's'
    }
  });
});

// Graceful shutdown
const gracefulShutdown = (signal) => {
  console.log(`üõë ${signal} received, shutting down gracefully...`);
  
  // Clear proxy intervals
  Object.values(proxyManager.intervals).forEach(interval => {
    if (interval) clearInterval(interval);
  });
  proxyManager.intervals = {};
  
  // Cleanup cache
  cache.destroy();
  
  process.exit(0);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ Enhanced Proxy Bridge API with File-Based Cache running on port ${PORT}`);
  console.log(`üìñ Documentation: http://localhost:${PORT}/`);
  console.log(`üåê Standard: http://localhost:${PORT}/proxies?url=https://httpbin.org/ip`);
  console.log(`üé¨ Video: http://localhost:${PORT}/proxies?url=https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4`);
  console.log(`üìä Stats: http://localhost:${PORT}/proxies/stats`);
  console.log(`üíæ Cache: http://localhost:${PORT}/proxies/cache?entries=1`);
  console.log(`üîÑ Manual Reset: POST http://localhost:${PORT}/proxies/cache/reset`);
  console.log(`‚ù§Ô∏è Health: http://localhost:${PORT}/health`);
  console.log(`üìÅ Cache File: cache.txt (200MB limit, 3-hour auto-reset)`);
  
  // Start background tasks
  proxyManager.startBackgroundTasks();
});

module.exports = { app, proxyManager, cache };
