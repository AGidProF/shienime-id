const express = require("express");
const axios = require("axios");
const fs = require("fs").promises;
const path = require("path");
const crypto = require("crypto");
const cluster = require("cluster");
const os = require("os");
const { HttpsProxyAgent } = require("https-proxy-agent");

// ULTRA HIGH-SPEED OPTIMIZATION - PRIORITIZE SPEED OVER EVERYTHING
const SPEED_OPTIMIZATION = {
  maxOldSpaceSize: 14 * 1024, // 14GB untuk Node.js heap
  maxConcurrentRequests: 1000,  // MASSIVELY increased concurrent requests
  proxyTestConcurrency: 200,    // MUCH higher proxy testing concurrency
  batchSize: 1000,             // HUGE batch size for faster processing
  maxBufferSize: 1024 * 1024 * 1024, // 1GB buffer untuk responses
  preloadProxies: 20000,       // Preload TONS of proxies
  cachePrewarm: true,
  memoryBuffer: 8 * 1024 * 1024 * 1024, // 8GB memory buffer
  
  // SPEED-FOCUSED TIMEOUTS - MUCH FASTER
  proxyTestTimeout: 3000,      // 3 seconds timeout (was 8000)
  fetchTimeout: 5000,          // 5 seconds fetch timeout (was 15000)
  requestTimeout: 8000,        // 8 seconds request timeout (was 10000)
  
  // AGGRESSIVE PROXY MANAGEMENT
  maxRetries: 8,               // Reduce retries for speed (was 12)
  proxyFailFast: true,         // Immediately remove failed proxies
  fastProxyThreshold: 2000,    // Consider proxy fast if < 2s (was 3s)
  
  // PARALLEL PROCESSING
  parallelFetchSources: true,  // Fetch all proxy sources simultaneously
  parallelTesting: true,       // Test proxies in parallel batches
  instantFailover: true        // Switch proxies instantly on failure
};

const app = express();
const PORT = process.env.PORT || 3000;

// ULTRA-FAST p-limit implementation
function createFastLimit(concurrency) {
  let running = 0;
  const queue = [];
  
  const processNext = () => {
    if (running >= concurrency || queue.length === 0) return;
    
    const { fn, resolve, reject } = queue.shift();
    running++;
    
    // Use setImmediate for faster non-blocking execution
    setImmediate(async () => {
      try {
        const result = await fn();
        resolve(result);
      } catch (error) {
        reject(error);
      } finally {
        running--;
        processNext();
      }
    });
  };
  
  return function limit(fn) {
    return new Promise((resolve, reject) => {
      queue.push({ fn, resolve, reject });
      processNext();
    });
  };
}

// LIGHTNING-FAST proxy sources - curated for speed
const proxySources = [
  // FASTEST SOURCES FIRST
  "https://api.proxyscrape.com/v4/free-proxy-list/get?request=get_proxies&protocol=http&proxy_format=ipport&format=text&timeout=10000",
  "https://raw.githubusercontent.com/proxifly/free-proxy-list/refs/heads/main/proxies/protocols/http/data.txt",
  "https://raw.githubusercontent.com/monosans/proxy-list/refs/heads/main/proxies/http.txt",
  "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
  "https://raw.githubusercontent.com/jetkai/proxy-list/main/online-proxies/txt/proxies-http.txt",
  "https://raw.githubusercontent.com/elliottophellia/proxylist/refs/heads/master/results/mix_checked.txt",
  "https://raw.githubusercontent.com/dpangestuw/Free-Proxy/refs/heads/main/http_proxies.txt",
  
  // SECONDARY SOURCES
  "https://raw.githubusercontent.com/ebrasha/abdal-proxy-hub/refs/heads/main/http-proxy-list-by-EbraSha.txt",
  "https://raw.githubusercontent.com/databay-labs/free-proxy-list/refs/heads/master/http.txt",
  "https://raw.githubusercontent.com/saisuiu/Lionkings-Http-Proxys-Proxies/refs/heads/main/free.txt",
];

// ===============================
// ULTRA-FAST CACHE SYSTEM
// ===============================
class LightningCache {
  constructor() {
    this.cacheFile = path.join(__dirname, 'speed_cache.txt');
    this.maxCacheSize = 100 * 1024 * 1024; // Reduced to 100MB for speed
    this.resetInterval = 2 * 60 * 60 * 1000; // 2 hours for faster resets
    this.maxFileSize = 20 * 1024 * 1024; // 20MB max file size
    
    // MASSIVE in-memory cache for SPEED
    this.memoryCache = new Map();
    this.memoryCacheSize = 0;
    this.maxMemoryCacheSize = 2 * 1024 * 1024 * 1024; // 2GB in-memory cache!
    this.memoryCacheTTL = 60 * 60 * 1000; // 1 hour TTL
    
    // SPEED-focused stats
    this.stats = {
      hitCount: 0,
      missCount: 0,
      skipCount: 0,
      memoryHits: 0,
      totalRequests: 0,
      avgResponseTime: 0,
      lastReset: new Date()
    };
    
    // Fast streaming detection
    this.streamingExtensions = new Set([
      '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
      '.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a',
      '.zip', '.rar', '.7z', '.tar', '.gz', '.iso', '.bin', '.dmg'
    ]);
    
    this.initializeCache();
    this.startFastResetTimer();
    this.startFastMemoryCleanup();
  }

  startFastMemoryCleanup() {
    // Clean memory cache every 2 minutes (faster)
    setInterval(() => {
      this.cleanMemoryCache();
    }, 2 * 60 * 1000);
  }

  cleanMemoryCache() {
    const now = Date.now();
    let cleaned = 0;
    let freedSize = 0;
    
    // FAST cleanup - remove expired items quickly
    const toDelete = [];
    for (const [key, value] of this.memoryCache.entries()) {
      if (now - value.timestamp > this.memoryCacheTTL) {
        toDelete.push(key);
        freedSize += value.size;
        cleaned++;
      }
    }
    
    // Batch delete for speed
    toDelete.forEach(key => this.memoryCache.delete(key));
    this.memoryCacheSize -= freedSize;
    
    if (cleaned > 0) {
      console.log(`⚡ FAST Memory cleanup: ${cleaned} entries, ${Math.round(freedSize/1024/1024)}MB freed`);
    }
  }

  async initializeCache() {
    try {
      await fs.access(this.cacheFile);
      console.log('⚡ Lightning cache ready');
    } catch (error) {
      await fs.writeFile(this.cacheFile, '{}');
      console.log('⚡ Lightning cache created');
    }
  }

  generateKey(url) {
    // Faster hashing
    return crypto.createHash('md5').update(url).digest('hex');
  }

  shouldCache(url, contentType, contentLength) {
    // ULTRA-FAST cache decision
    if (contentLength && contentLength > this.maxFileSize) return false;
    
    if (contentType) {
      const type = contentType.toLowerCase();
      if (type.includes('video/') || type.includes('audio/')) return false;
    }
    
    // Quick extension check
    const urlLower = url.toLowerCase();
    for (const ext of this.streamingExtensions) {
      if (urlLower.includes(ext)) return false;
    }
    
    return true;
  }

  async fastSet(url, data, headers, contentType) {
    try {
      const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data.toString());
      const contentLength = dataBuffer.length;
      
      if (!this.shouldCache(url, contentType, contentLength)) {
        this.stats.skipCount++;
        return false;
      }

      const key = this.generateKey(url);
      
      // PRIORITY: In-memory cache for SPEED
      if (contentLength < 50 * 1024 * 1024 && // Cache files < 50MB in memory
          this.memoryCacheSize + contentLength < this.maxMemoryCacheSize) {
        
        this.memoryCache.set(key, {
          data: dataBuffer,
          headers: headers || {},
          contentType: contentType || 'application/octet-stream',
          timestamp: Date.now(),
          size: contentLength,
          url: url // For debugging
        });
        this.memoryCacheSize += contentLength;
        
        console.log(`⚡ LIGHTNING Cache: ${url} (${Math.round(contentLength/1024)}KB) - Memory: ${Math.round(this.memoryCacheSize/1024/1024)}MB`);
        return true;
      }
      
      return false; // Skip file cache for maximum speed

    } catch (error) {
      console.error('❌ Cache error:', error.message);
      return false;
    }
  }

  async fastGet(url) {
    try {
      const key = this.generateKey(url);
      
      // Check memory cache ONLY for speed
      const memoryItem = this.memoryCache.get(key);
      if (memoryItem) {
        this.stats.memoryHits++;
        this.stats.hitCount++;
        
        return {
          data: memoryItem.data,
          headers: memoryItem.headers,
          contentType: memoryItem.contentType,
          fromCache: true,
          source: 'memory'
        };
      }
      
      this.stats.missCount++;
      return null;

    } catch (error) {
      this.stats.missCount++;
      return null;
    }
  }

  startFastResetTimer() {
    setInterval(async () => {
      await this.fastReset();
    }, this.resetInterval);
  }

  async fastReset() {
    const oldMemSize = this.memoryCacheSize;
    const oldEntries = this.memoryCache.size;
    
    // FAST reset - just clear memory
    this.memoryCache.clear();
    this.memoryCacheSize = 0;
    
    this.stats = {
      hitCount: 0,
      missCount: 0,
      skipCount: 0,
      memoryHits: 0,
      totalRequests: 0,
      avgResponseTime: 0,
      lastReset: new Date()
    };
    
    console.log(`⚡ LIGHTNING RESET: ${oldEntries} entries (${Math.round(oldMemSize/1024/1024)}MB) cleared`);
  }

  getStats() {
    const totalRequests = this.stats.hitCount + this.stats.missCount;
    const hitRate = totalRequests > 0 ? ((this.stats.hitCount / totalRequests) * 100).toFixed(1) + '%' : '0%';
    
    return {
      type: 'lightning-memory-only',
      memoryCache: {
        entries: this.memoryCache.size,
        sizeMB: Math.round(this.memoryCacheSize / 1024 / 1024),
        maxSizeMB: Math.round(this.maxMemoryCacheSize / 1024 / 1024),
        hitRate: hitRate,
        memoryHits: this.stats.memoryHits
      },
      performance: 'LIGHTNING SPEED MODE',
      resetInterval: '2 hours'
    };
  }

  destroy() {
    this.memoryCache.clear();
    console.log('⚡ Lightning cache shutdown');
  }
}

// ===============================
// LIGHTNING-SPEED PROXY MANAGER
// ===============================
class LightningProxyManager {
  constructor() {
    this.workingProxies = new Map();
    this.allProxies = new Set();
    this.deadProxies = new Set(); // Just a Set for speed, no metadata
    this.testingQueue = new Set();
    this.fastProxies = new Array(); // Array for faster access
    
    // SPEED-OPTIMIZED data structures
    this.proxyResponseTimes = new Map(); // Simple response time tracking
    this.recentlyUsed = new Set(); // Track recently used proxies
    this.proxyFailCount = new Map(); // Simple fail counting
    
    // LIGHTNING stats
    this.stats = {
      totalFetched: 0,
      totalTested: 0,
      totalWorking: 0,
      fastCount: 0,
      lastUpdate: null,
      fetchSpeed: 0,
      testSpeed: 0
    };
    
    this.intervals = {};
    this.isFetching = false;
    this.isTesting = false;
    
    // Start SPEED monitoring
    this.startSpeedMonitoring();
  }

  startSpeedMonitoring() {
    setInterval(() => {
      // Keep only fast proxies in the front of the array
      if (this.fastProxies.length > 50) {
        this.fastProxies = this.fastProxies.slice(0, 50); // Keep only top 50
      }
      
      // Clear old recently used proxies
      if (this.recentlyUsed.size > 100) {
        this.recentlyUsed.clear();
      }
    }, 30000);
  }

  async lightningFetchProxies() {
    if (this.isFetching) {
      console.log("⚡ Already fetching at lightning speed...");
      return this.allProxies;
    }

    this.isFetching = true;
    const startTime = Date.now();
    console.log("⚡ LIGHTNING FETCH: Starting ultra-fast proxy collection...");
    
    // Use MAXIMUM concurrency for fetching
    const limit = createFastLimit(proxySources.length); // All sources simultaneously!
    const newProxies = new Set(); // Use Set for deduplication
    
    const fetchPromises = proxySources.map((url, index) =>
      limit(async () => {
        try {
          console.log(`⚡ [${index + 1}] FETCHING: ${url.split('/')[2]}`);
          
          const response = await axios.get(url, {
            timeout: SPEED_OPTIMIZATION.fetchTimeout, // 5 seconds max
            maxRedirects: 2, // Reduced redirects
            maxContentLength: SPEED_OPTIMIZATION.maxBufferSize,
            validateStatus: () => true // Accept any status for speed
          });
          
          if (response.status !== 200) {
            console.log(`⚠️ [${index + 1}] Non-200 status: ${response.status}`);
            return 0;
          }
          
          let proxies = [];
          if (url.includes("geonode")) {
            if (response.data && response.data.data) {
              proxies = response.data.data.map(p => `${p.ip}:${p.port}`);
            }
          } else {
            // ULTRA-FAST parsing
            const lines = response.data.split('\n');
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line && line.includes(':')) {
                const cleanLine = line.replace(/^https?:\/\//, '');
                if (cleanLine.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/)) {
                  proxies.push(cleanLine);
                  newProxies.add(cleanLine); // Add to Set immediately
                }
              }
            }
          }
          
          console.log(`✅ [${index + 1}] GOT ${proxies.length} proxies from ${url.split('/')[2]}`);
          return proxies.length;
          
        } catch (err) {
          console.log(`❌ [${index + 1}] FAILED: ${url.split('/')[2]} - ${err.message}`);
          return 0;
        }
      })
    );
    
    const results = await Promise.allSettled(fetchPromises);
    const totalNew = Array.from(newProxies).length;
    
    // Merge with existing proxies
    const beforeSize = this.allProxies.size;
    newProxies.forEach(proxy => this.allProxies.add(proxy));
    const actualNew = this.allProxies.size - beforeSize;
    
    const duration = Date.now() - startTime;
    this.stats.fetchSpeed = Math.round(totalNew / (duration / 1000)); // proxies per second
    this.stats.totalFetched = this.allProxies.size;
    this.stats.lastUpdate = new Date();
    
    console.log(`⚡ LIGHTNING FETCH COMPLETE: ${totalNew} collected, ${actualNew} new, ${this.allProxies.size} total`);
    console.log(`⚡ SPEED: ${this.stats.fetchSpeed} proxies/second (${duration}ms total)`);
    
    this.isFetching = false;
    return this.allProxies;
  }

  async lightningTestProxy(proxy, testUrls = [
    "https://httpbin.org/ip", // Fastest test endpoint
    "https://api.github.com", // Reliable backup
  ]) {
    const startTime = Date.now();
    
    // Test ONLY the fastest endpoints for speed
    for (const testUrl of testUrls) {
      try {
        const agent = new HttpsProxyAgent(`http://${proxy}`);
        const response = await axios.get(testUrl, {
          httpAgent: agent,
          httpsAgent: agent,
          timeout: SPEED_OPTIMIZATION.proxyTestTimeout, // 3 seconds max!
          maxRedirects: 1, // Minimal redirects
          validateStatus: () => true,
          maxContentLength: 1024 * 1024 // 1MB max for test
        });
        
        const responseTime = Date.now() - startTime;
        
        if (response.status === 200 && response.data) {
          // Store simple response time
          this.proxyResponseTimes.set(proxy, responseTime);
          
          return {
            proxy,
            responseTime,
            success: true,
            testUrl,
            fast: responseTime < SPEED_OPTIMIZATION.fastProxyThreshold
          };
        }
      } catch (err) {
        continue; // Try next URL quickly
      }
    }
    
    return {
      proxy,
      responseTime: Date.now() - startTime,
      success: false
    };
  }

  getLightningProxy() {
    // ULTRA-FAST proxy selection
    
    // 1. Try fast proxies first
    if (this.fastProxies.length > 0) {
      // Get a random fast proxy that wasn't used recently
      for (let i = 0; i < Math.min(10, this.fastProxies.length); i++) {
        const proxy = this.fastProxies[Math.floor(Math.random() * this.fastProxies.length)];
        if (!this.recentlyUsed.has(proxy)) {
          this.recentlyUsed.add(proxy);
          return proxy;
        }
      }
      
      // If all fast proxies recently used, just pick any fast one
      const proxy = this.fastProxies[Math.floor(Math.random() * this.fastProxies.length)];
      this.recentlyUsed.add(proxy);
      return proxy;
    }
    
    // 2. Fallback to any working proxy
    if (this.workingProxies.size > 0) {
      const proxies = Array.from(this.workingProxies.keys());
      const proxy = proxies[Math.floor(Math.random() * proxies.length)];
      this.recentlyUsed.add(proxy);
      return proxy;
    }
    
    return null;
  }

  lightningRemoveProxy(proxy) {
    if (this.workingProxies.has(proxy)) {
      this.workingProxies.delete(proxy);
      this.deadProxies.add(proxy);
      
      // Remove from fast proxies array quickly
      const index = this.fastProxies.indexOf(proxy);
      if (index > -1) {
        this.fastProxies.splice(index, 1);
      }
      
      this.stats.totalWorking = this.workingProxies.size;
      this.stats.fastCount = this.fastProxies.length;
      
      console.log(`⚡ REMOVED: ${proxy} (${this.workingProxies.size} working, ${this.fastProxies.length} fast)`);
    }
  }

  async lightningTestAllProxies() {
    if (this.isTesting) return;
    this.isTesting = true;
    
    const untestedProxies = Array.from(this.allProxies).filter(proxy => 
      !this.workingProxies.has(proxy) && 
      !this.deadProxies.has(proxy) &&
      !this.testingQueue.has(proxy)
    );
    
    if (untestedProxies.length === 0) {
      this.isTesting = false;
      return;
    }

    const startTime = Date.now();
    console.log(`⚡ LIGHTNING TEST: ${untestedProxies.length} proxies with ${SPEED_OPTIMIZATION.proxyTestConcurrency} concurrent tests`);
    
    // Use MAXIMUM concurrency for testing
    const batchSize = SPEED_OPTIMIZATION.batchSize; // 1000
    const concurrency = SPEED_OPTIMIZATION.proxyTestConcurrency; // 200
    const limit = createFastLimit(concurrency);
    
    let totalTested = 0;
    let workingFound = 0;
    
    for (let i = 0; i < untestedProxies.length; i += batchSize) {
      const batch = untestedProxies.slice(i, i + batchSize);
      const batchStart = Date.now();
      
      console.log(`⚡ Testing batch: ${batch.length} proxies`);
      
      batch.forEach(proxy => this.testingQueue.add(proxy));
      
      const tasks = batch.map(proxy =>
        limit(async () => {
          const result = await this.lightningTestProxy(proxy);
          this.testingQueue.delete(proxy);
          
          if (result.success) {
            this.workingProxies.set(proxy, {
              responseTime: result.responseTime,
              addedAt: Date.now(),
              successCount: 1
            });
            
            // Add to fast proxies if it's fast
            if (result.fast) {
              this.fastProxies.push(proxy);
            }
            
            workingFound++;
          } else {
            this.deadProxies.add(proxy);
          }
          
          totalTested++;
          return result;
        })
      );

      await Promise.allSettled(tasks);
      
      const batchTime = Date.now() - batchStart;
      const batchSpeed = Math.round(batch.length / (batchTime / 1000));
      console.log(`⚡ Batch complete: ${batchSpeed} tests/sec (${workingFound} working, ${this.fastProxies.length} fast)`);
    }

    this.stats.totalWorking = this.workingProxies.size;
    this.stats.fastCount = this.fastProxies.length;
    this.stats.testingSessions++;
    
    const duration = Date.now() - startTime;
    this.stats.testSpeed = Math.round(totalTested / (duration / 1000));
    
    console.log(`⚡ LIGHTNING TEST COMPLETE: ${this.workingProxies.size} working, ${this.fastProxies.length} fast`);
    console.log(`⚡ SPEED: ${this.stats.testSpeed} tests/second (${duration}ms total)`);
    
    this.isTesting = false;
  }

  startLightningTasks() {
    console.log("⚡ Starting LIGHTNING PROXY MANAGER...");
    
    // Initial fetch and test
    this.lightningFetchProxies().then(() => {
      setTimeout(() => this.lightningTestAllProxies(), 2000); // Start testing after 2 seconds
    });

    // AGGRESSIVE refresh schedule
    this.intervals.fetch = setInterval(async () => {
      await this.lightningFetchProxies();
      if (!this.isTesting) {
        setTimeout(() => this.lightningTestAllProxies(), 2000);
      }
    }, 10 * 60 * 1000); // Every 10 minutes (was 20)

    // Quick maintenance
    this.intervals.maintenance = setInterval(() => {
      this.lightningMaintenance();
    }, 2 * 60 * 1000); // Every 2 minutes
  }

  lightningMaintenance() {
    // Quick maintenance - just keep the fast proxies list clean
    if (this.fastProxies.length > 100) {
      this.fastProxies = this.fastProxies.slice(0, 100);
    }
    
    // Clear old recently used
    if (this.recentlyUsed.size > 200) {
      this.recentlyUsed.clear();
    }
  }

  getStats() {
    return {
      mode: 'LIGHTNING SPEED',
      proxies: {
        total: this.allProxies.size,
        working: this.workingProxies.size,
        fast: this.fastProxies.length,
        dead: this.deadProxies.size
      },
      performance: {
        fetchSpeed: this.stats.fetchSpeed + ' proxies/sec',
        testSpeed: this.stats.testSpeed + ' tests/sec',
        concurrency: SPEED_OPTIMIZATION.proxyTestConcurrency,
        batchSize: SPEED_OPTIMIZATION.batchSize
      },
      status: {
        isFetching: this.isFetching,
        isTesting: this.isTesting,
        lastUpdate: this.stats.lastUpdate
      },
      optimization: SPEED_OPTIMIZATION
    };
  }

  destroy() {
    Object.values(this.intervals).forEach(interval => {
      if (interval) clearInterval(interval);
    });
    console.log('⚡ Lightning proxy manager shutdown');
  }
}

// ===============================
// LIGHTNING-FAST FETCH FUNCTION
// ===============================
async function lightningFetch(url, req, maxRetries = SPEED_OPTIMIZATION.maxRetries, useCache = true, cache) {
  const isRangeRequest = req.headers.range;
  
  if (isRangeRequest) {
    console.log(`⚡ RANGE REQUEST: ${url} (${req.headers.range})`);
    useCache = false;
  }

  // LIGHTNING cache check
  if (useCache) {
    const cached = await cache.fastGet(url);
    if (cached) {
      console.log(`⚡ LIGHTNING HIT: ${url}`);
      return {
        data: cached.data,
        headers: cached.headers,
        contentType: cached.contentType,
        fromCache: true,
        source: 'lightning-cache'
      };
    }
  }

  if (proxyManager.workingProxies.size === 0) {
    throw new Error(`⚡ No working proxies available`);
  }

  const startTime = Date.now();
  let usedProxies = new Set();
  let lastError = null;

  // LIGHTNING-FAST retry loop
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const proxy = proxyManager.getLightningProxy();
    
    if (!proxy) {
      throw new Error("⚡ No lightning proxies available");
    }
    
    // Skip recently failed proxies for speed
    if (usedProxies.has(proxy) && usedProxies.size < 10) {
      continue;
    }
    
    usedProxies.add(proxy);
    
    try {
      const agent = new HttpsProxyAgent(`http://${proxy}`);
      
      // Minimal headers for speed
      const proxyHeaders = {};
      if (req.headers.range) proxyHeaders.Range = req.headers.range;
      if (req.headers['user-agent']) proxyHeaders['User-Agent'] = req.headers['user-agent'];
      
      const response = await axios.get(url, {
        httpAgent: agent,
        httpsAgent: agent,
        timeout: SPEED_OPTIMIZATION.requestTimeout, // 8 seconds
        maxRedirects: 2, // Minimal redirects for speed
        validateStatus: () => true,
        responseType: 'arraybuffer',
        headers: proxyHeaders,
        maxContentLength: SPEED_OPTIMIZATION.maxBufferSize,
        maxBodyLength: SPEED_OPTIMIZATION.maxBufferSize
      });
      
      const duration = Date.now() - startTime;
      
      if (response.status === 200 || response.status === 206) {
        const contentType = response.headers['content-type'];
        
        console.log(`⚡ SUCCESS: ${proxy} (${duration}ms, ${Math.round(response.data.length/1024)}KB)`);
        
        // LIGHTNING cache store
        let cached = false;
        if (useCache && response.status === 200) {
          cached = await cache.fastSet(url, response.data, response.headers, contentType);
        }
        
        return {
          data: response.data,
          headers: response.headers,
          contentType: contentType,
          proxy: proxy,
          duration: duration,
          attempts: attempt,
          fromCache: false,
          status: response.status,
          cached: cached,
          source: 'lightning-proxy'
        };
      } else {
        console.log(`⚡ BAD STATUS: ${proxy} (${response.status})`);
        lastError = `HTTP ${response.status}`;
        continue;
      }
      
    } catch (err) {
      lastError = err.message;
      console.log(`⚡ FAILED: ${proxy} (${err.message.substring(0, 50)})`);
      
      // INSTANT failover - remove failed proxy immediately
      if (SPEED_OPTIMIZATION.proxyFailFast) {
        proxyManager.lightningRemoveProxy(proxy);
      }
      
      if (attempt === maxRetries) {
        const duration = Date.now() - startTime;
        throw new Error(`⚡ All ${maxRetries} lightning attempts failed in ${duration}ms. Last error: ${lastError}`);
      }
    }
  }
}

// Initialize LIGHTNING managers
const proxyManager = new LightningProxyManager();
const cache = new LightningCache();

// ===============================
// LIGHTNING EXPRESS ROUTES
// ===============================
app.use(express.json({ limit: '100mb' }));
app.use(express.urlencoded({ limit: '100mb', extended: true }));

app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Range');
  
  // LIGHTNING headers
  res.header('X-Lightning-Mode', 'ACTIVE');
  res.header('X-Max-Concurrent', SPEED_OPTIMIZATION.maxConcurrentRequests);
  res.header('X-Speed-Optimized', 'ULTRA-FAST');
  
  next();
});

// LIGHTNING main proxy endpoint
app.get('/proxies', async (req, res) => {
  const { url, nocache } = req.query;
  
  if (!url) {
    return res.status(400).json({ 
      error: 'URL parameter required',
      example: '/proxies?url=https://example.com',
      mode: 'LIGHTNING SPEED',
      optimization: {
        maxConcurrency: SPEED_OPTIMIZATION.maxConcurrentRequests,
        proxyTestTimeout: SPEED_OPTIMIZATION.proxyTestTimeout + 'ms',
        requestTimeout: SPEED_OPTIMIZATION.requestTimeout + 'ms',
        instantFailover: SPEED_OPTIMIZATION.instantFailover
      }
    });
  }

  try {
    new URL(url);
  } catch (err) {
    return res.status(400).json({ error: 'Invalid URL format' });
  }

  const startTime = Date.now();
  const useCache = nocache !== '1' && nocache !== 'true';
  const isRangeRequest = !!req.headers.range;

  try {
    console.log(`⚡ LIGHTNING FETCH: ${url} ${isRangeRequest ? '(RANGE)' : ''} ${!useCache ? '(NO-CACHE)' : ''}`);
    
    const result = await lightningFetch(url, req, SPEED_OPTIMIZATION.maxRetries, useCache, cache);
    
    // Set response headers
    if (result.contentType) {
      res.set('Content-Type', result.contentType);
    }
    
    if (result.status === 206) {
      res.status(206);
      if (result.headers['content-range']) {
        res.set('Content-Range', result.headers['content-range']);
      }
      if (result.headers['accept-ranges']) {
        res.set('Accept-Ranges', result.headers['accept-ranges']);
      }
    }
    
    if (result.headers['content-length']) {
      res.set('Content-Length', result.headers['content-length']);
    }
    
    if (result.contentType && (result.contentType.includes('video/') || result.contentType.includes('audio/'))) {
      res.set('Accept-Ranges', 'bytes');
    }
    
    // LIGHTNING performance headers
    res.set('X-Lightning-Proxy', result.proxy || 'cache');
    res.set('X-Lightning-Time', `${result.duration || Date.now() - startTime}ms`);
    res.set('X-Lightning-Attempts', result.attempts || 0);
    res.set('X-Lightning-Cache', result.fromCache ? 'HIT' : (result.cached ? 'STORED' : 'SKIP'));
    res.set('X-Lightning-Working', proxyManager.workingProxies.size);
    res.set('X-Lightning-Fast', proxyManager.fastProxies.length);
    res.set('X-Lightning-Size', Math.round(result.data.length / 1024) + 'KB');
    res.set('X-Lightning-Source', result.source || 'unknown');
    
    res.send(result.data);
    
  } catch (err) {
    await cache.fastSet(url + '_error', 'error', {}, 'text/plain'); // Quick error cache
    
    const duration = Date.now() - startTime;
    console.error(`⚡ LIGHTNING ERROR after ${duration}ms:`, err.message);
    
    res.status(500).json({ 
      error: 'Lightning fetch failed',
      details: err.message,
      duration: `${duration}ms`,
      mode: 'LIGHTNING SPEED',
      workingProxies: proxyManager.workingProxies.size,
      fastProxies: proxyManager.fastProxies.length,
      optimization: 'Ultra-fast failover with instant proxy switching',
      suggestion: 'Lightning mode prioritizes speed over reliability - try again for different proxy'
    });
  }
});

// LIGHTNING stats endpoint
app.get('/proxies/stats', (req, res) => {
  const proxyStats = proxyManager.getStats();
  const cacheStats = cache.getStats();
  const memUsage = process.memoryUsage();
  
  res.json({
    mode: 'LIGHTNING SPEED OPTIMIZATION',
    performance: {
      totalRAM: `${Math.round(os.totalmem() / 1024 / 1024 / 1024)}GB`,
      heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
      maxConcurrency: SPEED_OPTIMIZATION.maxConcurrentRequests,
      proxyTestConcurrency: SPEED_OPTIMIZATION.proxyTestConcurrency,
      batchSize: SPEED_OPTIMIZATION.batchSize
    },
    proxies: proxyStats,
    cache: cacheStats,
    speedOptimization: SPEED_OPTIMIZATION,
    uptime: Math.round(process.uptime()) + 's'
  });
});

// LIGHTNING cache stats
app.get('/proxies/cache', (req, res) => {
  const cacheStats = cache.getStats();
  const memEntries = req.query.entries === '1';
  
  const response = {
    mode: 'LIGHTNING MEMORY CACHE',
    stats: cacheStats,
    configuration: {
      type: 'Memory-only for maximum speed',
      maxSize: `${Math.round(cache.maxMemoryCacheSize / 1024 / 1024 / 1024)}GB`,
      resetInterval: '2 hours',
      streaming: 'Auto-bypass for videos',
      fileCache: 'DISABLED for speed'
    },
    performance: {
      instantAccess: 'Memory-only storage',
      noFileIO: 'Zero disk operations',
      fastCleanup: 'Automated memory management'
    }
  };
  
  if (memEntries && cache.memoryCache.size > 0) {
    const entries = [];
    let count = 0;
    for (const [key, value] of cache.memoryCache.entries()) {
      if (count >= 50) break; // Show only first 50
      entries.push({
        url: value.url || 'unknown',
        size: Math.round(value.size / 1024) + 'KB',
        age: Math.round((Date.now() - value.timestamp) / 1000) + 's',
        contentType: value.contentType || 'unknown'
      });
      count++;
    }
    response.entries = entries;
  }
  
  res.json(response);
});

// LIGHTNING cache clear
app.delete('/proxies/cache', (req, res) => {
  const { url } = req.query;
  
  if (url) {
    const key = cache.generateKey(url);
    const existed = cache.memoryCache.has(key);
    if (existed) {
      const item = cache.memoryCache.get(key);
      cache.memoryCacheSize -= item.size;
      cache.memoryCache.delete(key);
    }
    
    res.json({ 
      message: existed ? `Lightning cache cleared for: ${url}` : `Cache entry not found: ${url}`,
      cleared: existed,
      mode: 'LIGHTNING MEMORY CACHE'
    });
  } else {
    const oldSize = cache.memoryCacheSize;
    const oldEntries = cache.memoryCache.size;
    
    cache.memoryCache.clear();
    cache.memoryCacheSize = 0;
    
    res.json({ 
      message: 'All lightning cache cleared',
      cleared: true,
      freedMemory: Math.round(oldSize / 1024 / 1024) + 'MB',
      clearedEntries: oldEntries,
      mode: 'LIGHTNING MEMORY CACHE'
    });
  }
});

// LIGHTNING proxy management
app.post('/proxies/test', async (req, res) => {
  if (proxyManager.isTesting) {
    return res.status(429).json({
      error: 'Lightning testing already in progress',
      mode: 'LIGHTNING SPEED'
    });
  }

  console.log('⚡ LIGHTNING TEST: Manual testing initiated...');
  
  // Start lightning testing
  proxyManager.lightningTestAllProxies().then(() => {
    console.log('⚡ LIGHTNING TEST: Manual testing completed');
  });
  
  res.json({
    message: 'Lightning proxy testing started',
    mode: 'ULTRA-FAST',
    configuration: {
      concurrency: SPEED_OPTIMIZATION.proxyTestConcurrency,
      batchSize: SPEED_OPTIMIZATION.batchSize,
      timeout: SPEED_OPTIMIZATION.proxyTestTimeout + 'ms',
      instantFailover: SPEED_OPTIMIZATION.proxyFailFast
    },
    estimatedTime: `${Math.ceil(proxyManager.allProxies.size / SPEED_OPTIMIZATION.batchSize)} lightning batches`
  });
});

app.post('/proxies/fetch', async (req, res) => {
  if (proxyManager.isFetching) {
    return res.status(429).json({
      error: 'Lightning fetch already in progress'
    });
  }

  console.log('⚡ LIGHTNING FETCH: Manual fetch initiated...');
  
  try {
    const result = await proxyManager.lightningFetchProxies();
    res.json({
      message: 'Lightning proxy fetch completed',
      totalProxies: result.size,
      sources: proxySources.length,
      mode: 'LIGHTNING SPEED',
      fetchSpeed: proxyManager.stats.fetchSpeed + ' proxies/sec'
    });
  } catch (error) {
    res.status(500).json({
      error: 'Lightning fetch failed',
      details: error.message,
      mode: 'LIGHTNING SPEED'
    });
  }
});

// LIGHTNING performance monitor
app.get('/performance', (req, res) => {
  const stats = proxyManager.getStats();
  const cacheStats = cache.getStats();
  const memUsage = process.memoryUsage();
  
  res.json({
    mode: 'LIGHTNING PERFORMANCE MONITORING',
    timestamp: new Date().toISOString(),
    server: {
      uptime: `${Math.round(process.uptime())}s`,
      optimization: 'LIGHTNING SPEED MODE',
      nodeVersion: process.version,
      totalRAM: Math.round(os.totalmem() / 1024 / 1024 / 1024) + 'GB',
      freeRAM: Math.round(os.freemem() / 1024 / 1024 / 1024) + 'GB'
    },
    memory: {
      heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + 'MB',
      heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024) + 'MB',
      external: Math.round(memUsage.external / 1024 / 1024) + 'MB'
    },
    lightning: {
      proxies: stats.proxies,
      cache: cacheStats.memoryCache,
      speeds: {
        fetch: stats.performance.fetchSpeed,
        test: stats.performance.testSpeed
      },
      optimization: SPEED_OPTIMIZATION
    }
  });
});

// LIGHTNING health check
app.get('/health', (req, res) => {
  const stats = proxyManager.getStats();
  const cacheStats = cache.getStats();
  const memUsage = process.memoryUsage();
  
  const health = {
    status: 'LIGHTNING',
    timestamp: new Date().toISOString(),
    uptime: Math.round(process.uptime()),
    mode: 'ULTRA-FAST SPEED OPTIMIZATION',
    memory: {
      used: Math.round(memUsage.heapUsed / 1024 / 1024) + 'MB',
      total: Math.round(memUsage.heapTotal / 1024 / 1024) + 'MB',
      system: Math.round(os.totalmem() / 1024 / 1024 / 1024) + 'GB'
    },
    proxies: {
      total: stats.proxies.total,
      working: stats.proxies.working,
      fast: stats.proxies.fast,
      testing: stats.status.isTesting,
      fetching: stats.status.isFetching
    },
    cache: {
      type: 'LIGHTNING MEMORY',
      entries: cacheStats.memoryCache.entries,
      sizeMB: cacheStats.memoryCache.sizeMB,
      hitRate: cacheStats.memoryCache.hitRate
    },
    performance: {
      fetchSpeed: stats.performance.fetchSpeed,
      testSpeed: stats.performance.testSpeed,
      maxConcurrency: SPEED_OPTIMIZATION.maxConcurrentRequests,
      instantFailover: SPEED_OPTIMIZATION.proxyFailFast
    }
  };
  
  if (health.proxies.working === 0) {
    health.status = 'LIGHTNING-DEGRADED';
    health.warning = 'No working proxies - lightning fetch in progress';
  }
  
  res.json(health);
});

// LIGHTNING documentation
app.get('/', (req, res) => {
  const memUsage = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
  const totalRAM = Math.round(os.totalmem() / 1024 / 1024 / 1024);
  
  res.json({
    name: 'LIGHTNING-SPEED Proxy Bridge API',
    version: '⚡ 7.0.0 LIGHTNING',
    description: 'Ultra-fast proxy bridge optimized for MAXIMUM SPEED with instant failover',
    
    lightningOptimization: {
      mode: 'LIGHTNING SPEED',
      totalRAM: `${totalRAM}GB`,
      currentMemory: `${memUsage}MB`,
      maxConcurrency: SPEED_OPTIMIZATION.maxConcurrentRequests,
      proxyTestTimeout: SPEED_OPTIMIZATION.proxyTestTimeout + 'ms',
      requestTimeout: SPEED_OPTIMIZATION.requestTimeout + 'ms',
      instantFailover: SPEED_OPTIMIZATION.proxyFailFast ? 'ENABLED' : 'DISABLED'
    },
    
    endpoints: {
      'LIGHTNING Proxy': {
        'GET /proxies?url=<URL>': 'Lightning-fast proxy with instant failover',
        'GET /proxies?url=<URL>&nocache=1': 'Bypass lightning cache'
      },
      'LIGHTNING Stats': {
        'GET /proxies/stats': 'Lightning performance statistics',
        'GET /health': 'Lightning system health',
        'GET /performance': 'Lightning performance monitoring'
      },
      'LIGHTNING Cache': {
        'GET /proxies/cache': 'Lightning memory cache stats',
        'DELETE /proxies/cache': 'Clear lightning cache'
      },
      'LIGHTNING Control': {
        'POST /proxies/test': 'Lightning proxy testing',
        'POST /proxies/fetch': 'Lightning proxy fetch'
      }
    },

    lightningFeatures: [
      '⚡ INSTANT failover - failed proxies removed immediately',
      '🚀 Up to ' + SPEED_OPTIMIZATION.maxConcurrentRequests + ' concurrent requests',
      '💾 2GB memory-only cache for zero disk I/O',
      '🧠 ' + SPEED_OPTIMIZATION.proxyTestConcurrency + ' concurrent proxy tests',
      '⚡ ' + SPEED_OPTIMIZATION.proxyTestTimeout + 'ms proxy timeout for speed',
      '🎯 Smart fast proxy selection and rotation',
      '📦 ' + SPEED_OPTIMIZATION.batchSize + ' proxy batch processing',
      '🔄 Instant proxy switching on failure'
    ],

    speedOptimizations: [
      '⚡ Memory-only cache (NO file I/O)',
      '🚀 Instant proxy failover and removal',
      '💨 Ultra-fast proxy testing (3s timeout)',
      '🎯 Fast proxy prioritization',
      '📊 Minimal metadata tracking',
      '🧠 Smart batch processing',
      '⚡ Aggressive timeouts for speed',
      '💾 2GB memory cache capacity'
    ],

    videoStreamingFeatures: [
      '🎬 Full HTTP range request support',
      '📱 Mobile video streaming optimized',
      '⚡ Lightning-fast video proxy switching',
      '🎯 Auto-bypass cache for videos',
      '📺 All video formats supported',
      '🚀 Instant seeking and buffering'
    ],

    examples: {
      standard: '/proxies?url=https://httpbin.org/ip',
      video: '/proxies?url=https://example.com/video.mp4',
      api: '/proxies?url=https://api.example.com/data',
      speed: '/proxies?url=https://fast-api.com/endpoint'
    },

    lightningConfig: SPEED_OPTIMIZATION,

    currentStats: {
      proxies: proxyManager.getStats(),
      cache: cache.getStats(),
      memory: `${memUsage}MB / ${totalRAM}GB`,
      uptime: Math.round(process.uptime()) + 's',
      mode: 'LIGHTNING ACTIVE'
    },

    speedTips: [
      '⚡ Lightning mode prioritizes speed over stability',
      '🚀 Failed proxies are instantly removed and replaced',
      '💾 Memory-only cache eliminates disk I/O delays',
      '🎯 Fast proxies are automatically prioritized',
      '⚡ Aggressive timeouts ensure quick responses',
      '🔄 Instant failover prevents slow requests'
    ]
  });
});

// Graceful shutdown
const gracefulShutdown = (signal) => {
  console.log(`⚡ ${signal} - Lightning shutdown initiated...`);
  
  // Lightning cleanup
  proxyManager.destroy();
  cache.destroy();
  
  console.log('⚡ Lightning shutdown complete');
  process.exit(0);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

process.on('unhandledRejection', (reason, promise) => {
  console.error('⚡ Unhandled Rejection:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('⚡ Uncaught Exception:', error);
  gracefulShutdown('UNCAUGHT_EXCEPTION');
});

// Start LIGHTNING server
app.listen(PORT, () => {
  const memUsage = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
  const totalRAM = Math.round(os.totalmem() / 1024 / 1024 / 1024);
  
  console.log(`⚡ ═══════════════════════════════════════════════`);
  console.log(`⚡ LIGHTNING PROXY BRIDGE API - PORT ${PORT}`);
  console.log(`⚡ ═══════════════════════════════════════════════`);
  console.log(`💾 System RAM: ${totalRAM}GB (Using: ${memUsage}MB)`);
  console.log(`🚀 Max Concurrent: ${SPEED_OPTIMIZATION.maxConcurrentRequests}`);
  console.log(`🧪 Test Concurrent: ${SPEED_OPTIMIZATION.proxyTestConcurrency}`);
  console.log(`⏱️  Proxy Timeout: ${SPEED_OPTIMIZATION.proxyTestTimeout}ms`);
  console.log(`⏱️  Request Timeout: ${SPEED_OPTIMIZATION.requestTimeout}ms`);
  console.log(`💨 Instant Failover: ${SPEED_OPTIMIZATION.proxyFailFast ? 'ON' : 'OFF'}`);
  console.log(`📦 Batch Size: ${SPEED_OPTIMIZATION.batchSize}`);
  console.log(`💾 Memory Cache: ${Math.round(SPEED_OPTIMIZATION.memoryBuffer / 1024 / 1024 / 1024)}GB`);
  console.log(`⚡ ═══════════════════════════════════════════════`);
  console.log(`📖 Docs: http://localhost:${PORT}/`);
  console.log(`🌐 Test: http://localhost:${PORT}/proxies?url=https://httpbin.org/ip`);
  console.log(`📊 Stats: http://localhost:${PORT}/proxies/stats`);
  console.log(`❤️  Health: http://localhost:${PORT}/health`);
  console.log(`⚡ ═══════════════════════════════════════════════`);
  console.log(`⚡ LIGHTNING MODE: ULTRA-FAST PROXY BRIDGE READY!`);
  console.log(`⚡ ═══════════════════════════════════════════════`);
  
  // Start lightning tasks
  proxyManager.startLightningTasks();
  
  // Show memory status
  setTimeout(() => {
    const currentMem = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
    console.log(`⚡ Lightning memory: ${currentMem}MB active`);
    console.log(`⚡ Lightning optimization: SPEED PRIORITY MODE`);
  }, 3000);
});

module.exports = { app, proxyManager, cache, SPEED_OPTIMIZATION };
